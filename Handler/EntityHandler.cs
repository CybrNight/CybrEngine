using Microsoft.Xna.Framework;using Microsoft.Xna.Framework.Graphics;using System;using System.Collections;using System.Collections.Generic;using System.Diagnostics;using System.Linq;using System.Reflection;using System.Security.Cryptography;using System.Text;using System.Threading.Tasks;namespace CybrEngine {    public class EntityHandler : Handler {             private static List<Entity> entities = new List<Entity>();        private static Queue<Entity> creationQueue = new Queue<Entity>();        public EntityHandler() {                    }        /// <summary>        /// Method that handles updating all Entities        /// </summary>        public override void Update() {            //Instantiate all Entites queued from last update            InstantiateQueuedEntities();            Debug.WriteLine(entities.Count);            int startSize = entities.Count;            for(int i = 0; i < entities.Count; i++) {                Entity e = entities[i];                if(e.IsDestroyed) {                    //Remove Entity, and Destory ComponentList                    int index = e.ComponentIndex;                    entities.Remove(e);                    continue;                }                //If Entity Active, Update()                if(e.IsActive) {                    int index = e.ComponentIndex;                    e.Update();                }            }        }        public override void FixedUpdate() {            for(int i = 0; i < entities.Count; i++) {                Entity e = entities[i];                if(e.IsActive) {                    e.FixedUpdate();                    e.Position = new Vector2(e.Position.X + e.Velocity.X * Time.deltaTime,                                             e.Position.Y - e.Velocity.Y * Time.deltaTime);                }            }            //Check for entity intersections            for(int i = 0; i < entities.Count; i++) {                Entity e1 = entities[i];                for(int j = 0; j < entities.Count; j++) {                    Entity e2 = entities[j];                    if(e1 != e2) {                        if(e1.Intersects(e2)) {                            e1.OnIntersection(e2);                            e2.OnIntersection(e1);                        }                    }                }            }        }        public override void Draw(SpriteBatch spriteBatch) {            for (int i = 0; i < entities.Count; i++){                 Entity e = entities[i];                if(e.IsActive) {                    int index = e.ComponentIndex;                }            }        }        /// <summary>        /// Method to handle instantiating all queued objects from last update        /// </summary>        private void InstantiateQueuedEntities() {            while(creationQueue.Count > 0) {                var obj = creationQueue.Dequeue();                obj.Construct();                entities.Add(obj);                obj.Start();            }        }        /// <summary>        /// Adds new Entity to creationQueue, creates new ComponentList entry and returns reference to new Entity        /// </summary>        /// <param name="entity"></param>        /// <returns></returns>        public T Instantiate<T>() where T : Entity {            T entity = Builder.Entity<T>();            creationQueue.Enqueue(entity);            return entity;        }        /// <summary>        /// Adds new Entity object to creationQueue wih position        /// </summary>        /// <typeparam name="T"></typeparam>        /// <param name="position"></param>        /// <returns></returns>        public T Instantiate<T>(Vector2 position) where T : Entity {            T entity = Instantiate<T>();            entity.Position = position;            return entity;        }    }}